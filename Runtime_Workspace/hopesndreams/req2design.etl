pre{
		var desclass_created : Set;
}

rule root2root
	transform sourceRoot : requirement!Requirement_Root
	to targetRoot : design!Class_Diagram_Root{
		targetRoot.desclass.addAll(sourceRoot.designelement.equivalent().flatten().select(cls | cls.isKindOf(design!DesClass)));
		targetRoot.reference.addAll(sourceRoot.requirements.equivalent().flatten().select(ref | ref.isKindOf(design!Association)));
	}
	
rule designElement2desClass
	transform desElement : requirement!DesignElement
	to desClass : design!DesClass{
		desClass.name = desElement.name;
		desclass_created.add(desClass);
		
	}

rule requirement2classNassociation
	transform req : requirement!Functional
	to assoc : design!Association{
		var traceList: Set = req.traceto.asSet();
		
		traceList.println("List of traces: ");
//		This if statement is to do a quick check if a requirement only has 2 classes it's connected traced to and creates a single association between them.
		if(traceList.size()== 2){
		
			for (d in desclass_created){
				if(d.name == traceList[0].name)
				assoc.target = d;
			}
			for (d in desclass_created){
				if(d.name == traceList[1].name)
				assoc.source = d;
			}
		}
//		If there is more than one class that a requirement is traced to, this will iterate through all of them to create a temporary set that will be used to create associations between all relevant classes.
		else if(traceList.size() > 2){
			var tempClassSet: Set;
			for(t in traceList){
				for(d in desclass_created){
					if(t.name == d.name){
						tempClassSet.add(d);
						break;
					}
				}
			}
			tempClassSet.println("Temp class list: ");
			var assocList: Sequence;
			var i:Integer = 0;
			while(i < tempClassSet.size()-1){
				if(i==0){
					assoc.source = tempClassSet[0];
					assoc.target = tempClassSet[1];
					i++;
				}
				else{
					"hello world".println();
					var anotherAssoc = new design!Association;
					assoc.class_diagram_root.println();
//					assoc.eContainer.add(anotherAssoc);
					anotherAssoc.source = tempClassSet[i];
					i++;
					anotherAssoc.target = tempClassSet[i];
				}
				
			}
		}
	}
	
	
	
	
	
//rule spec2op
//	transform spec : requirement!Requirements
//	to op : design!Class{
//	
//	}