import "HelperFunctions.eol";

pre{
	var functionals :Integer = 1;
}

rule root2root
	transform sourceRoot : design!Class_Diagram_Root
	to targetRoot : requirement!Requirement_Root{
		targetRoot.requirements.addAll(sourceRoot.class.equivalent().flatten().select(req | req.isKindOf(requirement!Requirements)));
		targetRoot.reference.addAll(sourceRoot.class.equivalent().flatten().select(ref | ref.isKindOf(requirement!Reference)));
		targetRoot.designelement.addAll(sourceRoot.class.equivalent().flatten().select(des | des.isKindOf(requirement!DesignElement)));
}

rule concreteClass2designElement
	transform designClass : design!ConcreteClass
	to desElement : requirement!DesignElement,
		req: requirement!Functional,
		link: requirement!Trace{
		desElement.name = designClass.name;
		req.setName("FunctionalReq");
		req.setID(functionals);
		functionals++;
		req.equivalent().size().println("Size of array of requirements: ");
		req.eContainer().println("Container is: ");
		link.requirement = req;
		link.designelement = desElement;
	}

//post{
//	var requirements : Set = requirement!Functional.equivalent();
//	requirements.println("Set of requirements: ");
//}


//rule concreteClass2designElement
//	transform source : design!ConcreteClass
//	to target : requirement!DesignElement{
//		target.name = source.name;
//	}
	

